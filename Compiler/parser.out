Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> program
Rule 2     program -> decl_list
Rule 3     decl_list -> decl
Rule 4     decl_list -> decl_list decl
Rule 5     decl -> var_decl
Rule 6     decl -> fun_decl
Rule 7     var_decl -> type_spec VARIABLE ;
Rule 8     var_decl -> type_spec VARIABLE [ NUMBER ] ;
Rule 9     type_spec -> VOID
Rule 10    type_spec -> INT
Rule 11    fun_decl -> type_spec VARIABLE ( params ) compound_stmt
Rule 12    fun_decl -> type_spec VARIABLE ( params ) ;
Rule 13    params -> param_list
Rule 14    params -> VOID
Rule 15    params -> empty
Rule 16    param_list -> param
Rule 17    param_list -> param_list , param
Rule 18    param -> type_spec VARIABLE
Rule 19    param -> type_spec VARIABLE [ NUMBER ]
Rule 20    stmt_list -> stmt_list stmt
Rule 21    stmt_list -> empty
Rule 22    stmt -> expr_stmt
Rule 23    stmt -> block_stmt
Rule 24    stmt -> if_stmt
Rule 25    stmt -> while_stmt
Rule 26    stmt -> return_stmt
Rule 27    stmt -> continue_stmt
Rule 28    stmt -> break_stmt
Rule 29    stmt -> eret_stmt
Rule 30    eret_stmt -> ERET ;
Rule 31    expr_stmt -> VARIABLE = expr ;
Rule 32    expr_stmt -> VARIABLE [ expr ] = expr ;
Rule 33    expr_stmt -> $ expr = expr ;
Rule 34    expr_stmt -> expr ;
Rule 35    while_stmt -> WHILE ( expr ) stmt
Rule 36    block_stmt -> { stmt_list }
Rule 37    compound_stmt -> { local_decls stmt_list }
Rule 38    local_decls -> local_decls local_decl
Rule 39    local_decls -> empty
Rule 40    local_decl -> type_spec VARIABLE ;
Rule 41    local_decl -> type_spec VARIABLE [ NUMBER ] ;
Rule 42    if_stmt -> IF ( expr ) stmt
Rule 43    if_stmt -> IF ( expr ) stmt ELSE stmt
Rule 44    return_stmt -> RETURN ;
Rule 45    return_stmt -> RETURN expr ;
Rule 46    expr -> expr OR expr
Rule 47    expr -> expr AND expr
Rule 48    expr -> expr EQ expr
Rule 49    expr -> expr NE expr
Rule 50    expr -> expr LE expr
Rule 51    expr -> expr LT expr
Rule 52    expr -> expr GE expr
Rule 53    expr -> expr GT expr
Rule 54    expr -> expr * expr
Rule 55    expr -> expr / expr
Rule 56    expr -> expr % expr
Rule 57    expr -> expr + expr
Rule 58    expr -> expr - expr
Rule 59    expr -> expr & expr
Rule 60    expr -> expr ^ expr
Rule 61    expr -> expr | expr
Rule 62    expr -> expr LSHIFT expr
Rule 63    expr -> expr RSHIFT expr
Rule 64    expr -> ! expr
Rule 65    expr -> - expr
Rule 66    expr -> + expr
Rule 67    expr -> ~ expr
Rule 68    expr -> ( expr )
Rule 69    expr -> VARIABLE
Rule 70    expr -> NUMBER
Rule 71    expr -> $ expr
Rule 72    expr -> VARIABLE [ expr ]
Rule 73    expr -> VARIABLE ( args )
Rule 74    args -> arg_list
Rule 75    args -> empty
Rule 76    arg_list -> arg_list , expr
Rule 77    arg_list -> expr
Rule 78    continue_stmt -> CONTINUE ;
Rule 79    break_stmt -> BREAK ;
Rule 80    empty -> <empty>

Terminals, with rules where they appear

!                    : 64
$                    : 33 71
%                    : 56
&                    : 59
(                    : 11 12 35 42 43 68 73
)                    : 11 12 35 42 43 68 73
*                    : 54
+                    : 57 66
,                    : 17 76
-                    : 58 65
/                    : 55
;                    : 7 8 12 30 31 32 33 34 40 41 44 45 78 79
=                    : 31 32 33
AND                  : 47
BREAK                : 79
CONTINUE             : 78
ELSE                 : 43
EQ                   : 48
ERET                 : 30
GE                   : 52
GT                   : 53
IF                   : 42 43
INT                  : 10
LE                   : 50
LSHIFT               : 62
LT                   : 51
NE                   : 49
NUMBER               : 8 19 41 70
OR                   : 46
RETURN               : 44 45
RSHIFT               : 63
VARIABLE             : 7 8 11 12 18 19 31 32 40 41 69 72 73
VOID                 : 9 14
WHILE                : 35
[                    : 8 19 32 41 72
]                    : 8 19 32 41 72
^                    : 60
error                : 
{                    : 36 37
|                    : 61
}                    : 36 37
~                    : 67

Nonterminals, with rules where they appear

arg_list             : 74 76
args                 : 73
block_stmt           : 23
break_stmt           : 28
compound_stmt        : 11
continue_stmt        : 27
decl                 : 3 4
decl_list            : 2 4
empty                : 15 21 39 75
eret_stmt            : 29
expr                 : 31 32 32 33 33 34 35 42 43 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 65 66 67 68 71 72 76 77
expr_stmt            : 22
fun_decl             : 6
if_stmt              : 24
local_decl           : 38
local_decls          : 37 38
param                : 16 17
param_list           : 13 17
params               : 11 12
program              : 1
return_stmt          : 26
start                : 0
stmt                 : 20 35 42 43 43
stmt_list            : 20 36 37
type_spec            : 7 8 11 12 18 19 40 41
var_decl             : 5
while_stmt           : 25

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . program
    (2) program -> . decl_list
    (3) decl_list -> . decl
    (4) decl_list -> . decl_list decl
    (5) decl -> . var_decl
    (6) decl -> . fun_decl
    (7) var_decl -> . type_spec VARIABLE ;
    (8) var_decl -> . type_spec VARIABLE [ NUMBER ] ;
    (11) fun_decl -> . type_spec VARIABLE ( params ) compound_stmt
    (12) fun_decl -> . type_spec VARIABLE ( params ) ;
    (9) type_spec -> . VOID
    (10) type_spec -> . INT

    VOID            shift and go to state 3
    INT             shift and go to state 9

    decl                           shift and go to state 1
    type_spec                      shift and go to state 2
    fun_decl                       shift and go to state 4
    var_decl                       shift and go to state 5
    start                          shift and go to state 6
    program                        shift and go to state 7
    decl_list                      shift and go to state 8

state 1

    (3) decl_list -> decl .

    VOID            reduce using rule 3 (decl_list -> decl .)
    INT             reduce using rule 3 (decl_list -> decl .)
    $end            reduce using rule 3 (decl_list -> decl .)


state 2

    (7) var_decl -> type_spec . VARIABLE ;
    (8) var_decl -> type_spec . VARIABLE [ NUMBER ] ;
    (11) fun_decl -> type_spec . VARIABLE ( params ) compound_stmt
    (12) fun_decl -> type_spec . VARIABLE ( params ) ;

    VARIABLE        shift and go to state 10


state 3

    (9) type_spec -> VOID .

    VARIABLE        reduce using rule 9 (type_spec -> VOID .)


state 4

    (6) decl -> fun_decl .

    VOID            reduce using rule 6 (decl -> fun_decl .)
    INT             reduce using rule 6 (decl -> fun_decl .)
    $end            reduce using rule 6 (decl -> fun_decl .)


state 5

    (5) decl -> var_decl .

    VOID            reduce using rule 5 (decl -> var_decl .)
    INT             reduce using rule 5 (decl -> var_decl .)
    $end            reduce using rule 5 (decl -> var_decl .)


state 6

    (0) S' -> start .



state 7

    (1) start -> program .

    $end            reduce using rule 1 (start -> program .)


state 8

    (2) program -> decl_list .
    (4) decl_list -> decl_list . decl
    (5) decl -> . var_decl
    (6) decl -> . fun_decl
    (7) var_decl -> . type_spec VARIABLE ;
    (8) var_decl -> . type_spec VARIABLE [ NUMBER ] ;
    (11) fun_decl -> . type_spec VARIABLE ( params ) compound_stmt
    (12) fun_decl -> . type_spec VARIABLE ( params ) ;
    (9) type_spec -> . VOID
    (10) type_spec -> . INT

    $end            reduce using rule 2 (program -> decl_list .)
    VOID            shift and go to state 3
    INT             shift and go to state 9

    decl                           shift and go to state 11
    fun_decl                       shift and go to state 4
    type_spec                      shift and go to state 2
    var_decl                       shift and go to state 5

state 9

    (10) type_spec -> INT .

    VARIABLE        reduce using rule 10 (type_spec -> INT .)


state 10

    (7) var_decl -> type_spec VARIABLE . ;
    (8) var_decl -> type_spec VARIABLE . [ NUMBER ] ;
    (11) fun_decl -> type_spec VARIABLE . ( params ) compound_stmt
    (12) fun_decl -> type_spec VARIABLE . ( params ) ;

    ;               shift and go to state 13
    [               shift and go to state 14
    (               shift and go to state 12


state 11

    (4) decl_list -> decl_list decl .

    VOID            reduce using rule 4 (decl_list -> decl_list decl .)
    INT             reduce using rule 4 (decl_list -> decl_list decl .)
    $end            reduce using rule 4 (decl_list -> decl_list decl .)


state 12

    (11) fun_decl -> type_spec VARIABLE ( . params ) compound_stmt
    (12) fun_decl -> type_spec VARIABLE ( . params ) ;
    (13) params -> . param_list
    (14) params -> . VOID
    (15) params -> . empty
    (16) param_list -> . param
    (17) param_list -> . param_list , param
    (80) empty -> .
    (18) param -> . type_spec VARIABLE
    (19) param -> . type_spec VARIABLE [ NUMBER ]
    (9) type_spec -> . VOID
    (10) type_spec -> . INT

    VOID            shift and go to state 15
    )               reduce using rule 80 (empty -> .)
    INT             shift and go to state 9

    param_list                     shift and go to state 17
    param                          shift and go to state 16
    type_spec                      shift and go to state 18
    params                         shift and go to state 19
    empty                          shift and go to state 20

state 13

    (7) var_decl -> type_spec VARIABLE ; .

    VOID            reduce using rule 7 (var_decl -> type_spec VARIABLE ; .)
    INT             reduce using rule 7 (var_decl -> type_spec VARIABLE ; .)
    $end            reduce using rule 7 (var_decl -> type_spec VARIABLE ; .)


state 14

    (8) var_decl -> type_spec VARIABLE [ . NUMBER ] ;

    NUMBER          shift and go to state 21


state 15

    (14) params -> VOID .
    (9) type_spec -> VOID .

    )               reduce using rule 14 (params -> VOID .)
    VARIABLE        reduce using rule 9 (type_spec -> VOID .)


state 16

    (16) param_list -> param .

    ,               reduce using rule 16 (param_list -> param .)
    )               reduce using rule 16 (param_list -> param .)


state 17

    (13) params -> param_list .
    (17) param_list -> param_list . , param

    )               reduce using rule 13 (params -> param_list .)
    ,               shift and go to state 22


state 18

    (18) param -> type_spec . VARIABLE
    (19) param -> type_spec . VARIABLE [ NUMBER ]

    VARIABLE        shift and go to state 23


state 19

    (11) fun_decl -> type_spec VARIABLE ( params . ) compound_stmt
    (12) fun_decl -> type_spec VARIABLE ( params . ) ;

    )               shift and go to state 24


state 20

    (15) params -> empty .

    )               reduce using rule 15 (params -> empty .)


state 21

    (8) var_decl -> type_spec VARIABLE [ NUMBER . ] ;

    ]               shift and go to state 25


state 22

    (17) param_list -> param_list , . param
    (18) param -> . type_spec VARIABLE
    (19) param -> . type_spec VARIABLE [ NUMBER ]
    (9) type_spec -> . VOID
    (10) type_spec -> . INT

    VOID            shift and go to state 3
    INT             shift and go to state 9

    type_spec                      shift and go to state 18
    param                          shift and go to state 26

state 23

    (18) param -> type_spec VARIABLE .
    (19) param -> type_spec VARIABLE . [ NUMBER ]

    ,               reduce using rule 18 (param -> type_spec VARIABLE .)
    )               reduce using rule 18 (param -> type_spec VARIABLE .)
    [               shift and go to state 27


state 24

    (11) fun_decl -> type_spec VARIABLE ( params ) . compound_stmt
    (12) fun_decl -> type_spec VARIABLE ( params ) . ;
    (37) compound_stmt -> . { local_decls stmt_list }

    ;               shift and go to state 29
    {               shift and go to state 28

    compound_stmt                  shift and go to state 30

state 25

    (8) var_decl -> type_spec VARIABLE [ NUMBER ] . ;

    ;               shift and go to state 31


state 26

    (17) param_list -> param_list , param .

    ,               reduce using rule 17 (param_list -> param_list , param .)
    )               reduce using rule 17 (param_list -> param_list , param .)


state 27

    (19) param -> type_spec VARIABLE [ . NUMBER ]

    NUMBER          shift and go to state 32


state 28

    (37) compound_stmt -> { . local_decls stmt_list }
    (38) local_decls -> . local_decls local_decl
    (39) local_decls -> . empty
    (80) empty -> .

    VOID            reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    }               reduce using rule 80 (empty -> .)
    VARIABLE        reduce using rule 80 (empty -> .)
    $               reduce using rule 80 (empty -> .)
    {               reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    ERET            reduce using rule 80 (empty -> .)
    !               reduce using rule 80 (empty -> .)
    -               reduce using rule 80 (empty -> .)
    +               reduce using rule 80 (empty -> .)
    ~               reduce using rule 80 (empty -> .)
    (               reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)

    local_decls                    shift and go to state 33
    empty                          shift and go to state 34

state 29

    (12) fun_decl -> type_spec VARIABLE ( params ) ; .

    VOID            reduce using rule 12 (fun_decl -> type_spec VARIABLE ( params ) ; .)
    INT             reduce using rule 12 (fun_decl -> type_spec VARIABLE ( params ) ; .)
    $end            reduce using rule 12 (fun_decl -> type_spec VARIABLE ( params ) ; .)


state 30

    (11) fun_decl -> type_spec VARIABLE ( params ) compound_stmt .

    VOID            reduce using rule 11 (fun_decl -> type_spec VARIABLE ( params ) compound_stmt .)
    INT             reduce using rule 11 (fun_decl -> type_spec VARIABLE ( params ) compound_stmt .)
    $end            reduce using rule 11 (fun_decl -> type_spec VARIABLE ( params ) compound_stmt .)


state 31

    (8) var_decl -> type_spec VARIABLE [ NUMBER ] ; .

    VOID            reduce using rule 8 (var_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    INT             reduce using rule 8 (var_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    $end            reduce using rule 8 (var_decl -> type_spec VARIABLE [ NUMBER ] ; .)


state 32

    (19) param -> type_spec VARIABLE [ NUMBER . ]

    ]               shift and go to state 35


state 33

    (37) compound_stmt -> { local_decls . stmt_list }
    (38) local_decls -> local_decls . local_decl
    (20) stmt_list -> . stmt_list stmt
    (21) stmt_list -> . empty
    (40) local_decl -> . type_spec VARIABLE ;
    (41) local_decl -> . type_spec VARIABLE [ NUMBER ] ;
    (80) empty -> .
    (9) type_spec -> . VOID
    (10) type_spec -> . INT

    }               reduce using rule 80 (empty -> .)
    VARIABLE        reduce using rule 80 (empty -> .)
    $               reduce using rule 80 (empty -> .)
    {               reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    ERET            reduce using rule 80 (empty -> .)
    !               reduce using rule 80 (empty -> .)
    -               reduce using rule 80 (empty -> .)
    +               reduce using rule 80 (empty -> .)
    ~               reduce using rule 80 (empty -> .)
    (               reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)
    VOID            shift and go to state 3
    INT             shift and go to state 9

    stmt_list                      shift and go to state 36
    local_decl                     shift and go to state 37
    type_spec                      shift and go to state 38
    empty                          shift and go to state 39

state 34

    (39) local_decls -> empty .

    VOID            reduce using rule 39 (local_decls -> empty .)
    INT             reduce using rule 39 (local_decls -> empty .)
    }               reduce using rule 39 (local_decls -> empty .)
    VARIABLE        reduce using rule 39 (local_decls -> empty .)
    $               reduce using rule 39 (local_decls -> empty .)
    {               reduce using rule 39 (local_decls -> empty .)
    IF              reduce using rule 39 (local_decls -> empty .)
    WHILE           reduce using rule 39 (local_decls -> empty .)
    RETURN          reduce using rule 39 (local_decls -> empty .)
    CONTINUE        reduce using rule 39 (local_decls -> empty .)
    BREAK           reduce using rule 39 (local_decls -> empty .)
    ERET            reduce using rule 39 (local_decls -> empty .)
    !               reduce using rule 39 (local_decls -> empty .)
    -               reduce using rule 39 (local_decls -> empty .)
    +               reduce using rule 39 (local_decls -> empty .)
    ~               reduce using rule 39 (local_decls -> empty .)
    (               reduce using rule 39 (local_decls -> empty .)
    NUMBER          reduce using rule 39 (local_decls -> empty .)


state 35

    (19) param -> type_spec VARIABLE [ NUMBER ] .

    ,               reduce using rule 19 (param -> type_spec VARIABLE [ NUMBER ] .)
    )               reduce using rule 19 (param -> type_spec VARIABLE [ NUMBER ] .)


state 36

    (37) compound_stmt -> { local_decls stmt_list . }
    (20) stmt_list -> stmt_list . stmt
    (22) stmt -> . expr_stmt
    (23) stmt -> . block_stmt
    (24) stmt -> . if_stmt
    (25) stmt -> . while_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . continue_stmt
    (28) stmt -> . break_stmt
    (29) stmt -> . eret_stmt
    (31) expr_stmt -> . VARIABLE = expr ;
    (32) expr_stmt -> . VARIABLE [ expr ] = expr ;
    (33) expr_stmt -> . $ expr = expr ;
    (34) expr_stmt -> . expr ;
    (36) block_stmt -> . { stmt_list }
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (35) while_stmt -> . WHILE ( expr ) stmt
    (44) return_stmt -> . RETURN ;
    (45) return_stmt -> . RETURN expr ;
    (78) continue_stmt -> . CONTINUE ;
    (79) break_stmt -> . BREAK ;
    (30) eret_stmt -> . ERET ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    }               shift and go to state 64
    VARIABLE        shift and go to state 53
    $               shift and go to state 45
    {               shift and go to state 63
    IF              shift and go to state 55
    WHILE           shift and go to state 42
    RETURN          shift and go to state 40
    CONTINUE        shift and go to state 61
    BREAK           shift and go to state 59
    ERET            shift and go to state 57
    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    NUMBER          shift and go to state 41

    break_stmt                     shift and go to state 44
    if_stmt                        shift and go to state 56
    continue_stmt                  shift and go to state 46
    block_stmt                     shift and go to state 49
    while_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 43
    stmt                           shift and go to state 51
    eret_stmt                      shift and go to state 50
    expr                           shift and go to state 58
    expr_stmt                      shift and go to state 54

state 37

    (38) local_decls -> local_decls local_decl .

    VOID            reduce using rule 38 (local_decls -> local_decls local_decl .)
    INT             reduce using rule 38 (local_decls -> local_decls local_decl .)
    }               reduce using rule 38 (local_decls -> local_decls local_decl .)
    VARIABLE        reduce using rule 38 (local_decls -> local_decls local_decl .)
    $               reduce using rule 38 (local_decls -> local_decls local_decl .)
    {               reduce using rule 38 (local_decls -> local_decls local_decl .)
    IF              reduce using rule 38 (local_decls -> local_decls local_decl .)
    WHILE           reduce using rule 38 (local_decls -> local_decls local_decl .)
    RETURN          reduce using rule 38 (local_decls -> local_decls local_decl .)
    CONTINUE        reduce using rule 38 (local_decls -> local_decls local_decl .)
    BREAK           reduce using rule 38 (local_decls -> local_decls local_decl .)
    ERET            reduce using rule 38 (local_decls -> local_decls local_decl .)
    !               reduce using rule 38 (local_decls -> local_decls local_decl .)
    -               reduce using rule 38 (local_decls -> local_decls local_decl .)
    +               reduce using rule 38 (local_decls -> local_decls local_decl .)
    ~               reduce using rule 38 (local_decls -> local_decls local_decl .)
    (               reduce using rule 38 (local_decls -> local_decls local_decl .)
    NUMBER          reduce using rule 38 (local_decls -> local_decls local_decl .)


state 38

    (40) local_decl -> type_spec . VARIABLE ;
    (41) local_decl -> type_spec . VARIABLE [ NUMBER ] ;

    VARIABLE        shift and go to state 66


state 39

    (21) stmt_list -> empty .

    }               reduce using rule 21 (stmt_list -> empty .)
    VARIABLE        reduce using rule 21 (stmt_list -> empty .)
    $               reduce using rule 21 (stmt_list -> empty .)
    {               reduce using rule 21 (stmt_list -> empty .)
    IF              reduce using rule 21 (stmt_list -> empty .)
    WHILE           reduce using rule 21 (stmt_list -> empty .)
    RETURN          reduce using rule 21 (stmt_list -> empty .)
    CONTINUE        reduce using rule 21 (stmt_list -> empty .)
    BREAK           reduce using rule 21 (stmt_list -> empty .)
    ERET            reduce using rule 21 (stmt_list -> empty .)
    !               reduce using rule 21 (stmt_list -> empty .)
    -               reduce using rule 21 (stmt_list -> empty .)
    +               reduce using rule 21 (stmt_list -> empty .)
    ~               reduce using rule 21 (stmt_list -> empty .)
    (               reduce using rule 21 (stmt_list -> empty .)
    NUMBER          reduce using rule 21 (stmt_list -> empty .)


state 40

    (44) return_stmt -> RETURN . ;
    (45) return_stmt -> RETURN . expr ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    ;               shift and go to state 68
    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 70

state 41

    (70) expr -> NUMBER .

    OR              reduce using rule 70 (expr -> NUMBER .)
    AND             reduce using rule 70 (expr -> NUMBER .)
    EQ              reduce using rule 70 (expr -> NUMBER .)
    NE              reduce using rule 70 (expr -> NUMBER .)
    LE              reduce using rule 70 (expr -> NUMBER .)
    LT              reduce using rule 70 (expr -> NUMBER .)
    GE              reduce using rule 70 (expr -> NUMBER .)
    GT              reduce using rule 70 (expr -> NUMBER .)
    *               reduce using rule 70 (expr -> NUMBER .)
    /               reduce using rule 70 (expr -> NUMBER .)
    %               reduce using rule 70 (expr -> NUMBER .)
    +               reduce using rule 70 (expr -> NUMBER .)
    -               reduce using rule 70 (expr -> NUMBER .)
    &               reduce using rule 70 (expr -> NUMBER .)
    ^               reduce using rule 70 (expr -> NUMBER .)
    |               reduce using rule 70 (expr -> NUMBER .)
    LSHIFT          reduce using rule 70 (expr -> NUMBER .)
    RSHIFT          reduce using rule 70 (expr -> NUMBER .)
    ;               reduce using rule 70 (expr -> NUMBER .)
    =               reduce using rule 70 (expr -> NUMBER .)
    )               reduce using rule 70 (expr -> NUMBER .)
    ,               reduce using rule 70 (expr -> NUMBER .)
    ]               reduce using rule 70 (expr -> NUMBER .)


state 42

    (35) while_stmt -> WHILE . ( expr ) stmt

    (               shift and go to state 71


state 43

    (26) stmt -> return_stmt .

    }               reduce using rule 26 (stmt -> return_stmt .)
    VARIABLE        reduce using rule 26 (stmt -> return_stmt .)
    $               reduce using rule 26 (stmt -> return_stmt .)
    {               reduce using rule 26 (stmt -> return_stmt .)
    IF              reduce using rule 26 (stmt -> return_stmt .)
    WHILE           reduce using rule 26 (stmt -> return_stmt .)
    RETURN          reduce using rule 26 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 26 (stmt -> return_stmt .)
    BREAK           reduce using rule 26 (stmt -> return_stmt .)
    ERET            reduce using rule 26 (stmt -> return_stmt .)
    !               reduce using rule 26 (stmt -> return_stmt .)
    -               reduce using rule 26 (stmt -> return_stmt .)
    +               reduce using rule 26 (stmt -> return_stmt .)
    ~               reduce using rule 26 (stmt -> return_stmt .)
    (               reduce using rule 26 (stmt -> return_stmt .)
    NUMBER          reduce using rule 26 (stmt -> return_stmt .)
    ELSE            reduce using rule 26 (stmt -> return_stmt .)


state 44

    (28) stmt -> break_stmt .

    }               reduce using rule 28 (stmt -> break_stmt .)
    VARIABLE        reduce using rule 28 (stmt -> break_stmt .)
    $               reduce using rule 28 (stmt -> break_stmt .)
    {               reduce using rule 28 (stmt -> break_stmt .)
    IF              reduce using rule 28 (stmt -> break_stmt .)
    WHILE           reduce using rule 28 (stmt -> break_stmt .)
    RETURN          reduce using rule 28 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 28 (stmt -> break_stmt .)
    BREAK           reduce using rule 28 (stmt -> break_stmt .)
    ERET            reduce using rule 28 (stmt -> break_stmt .)
    !               reduce using rule 28 (stmt -> break_stmt .)
    -               reduce using rule 28 (stmt -> break_stmt .)
    +               reduce using rule 28 (stmt -> break_stmt .)
    ~               reduce using rule 28 (stmt -> break_stmt .)
    (               reduce using rule 28 (stmt -> break_stmt .)
    NUMBER          reduce using rule 28 (stmt -> break_stmt .)
    ELSE            reduce using rule 28 (stmt -> break_stmt .)


state 45

    (33) expr_stmt -> $ . expr = expr ;
    (71) expr -> $ . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 72

state 46

    (27) stmt -> continue_stmt .

    }               reduce using rule 27 (stmt -> continue_stmt .)
    VARIABLE        reduce using rule 27 (stmt -> continue_stmt .)
    $               reduce using rule 27 (stmt -> continue_stmt .)
    {               reduce using rule 27 (stmt -> continue_stmt .)
    IF              reduce using rule 27 (stmt -> continue_stmt .)
    WHILE           reduce using rule 27 (stmt -> continue_stmt .)
    RETURN          reduce using rule 27 (stmt -> continue_stmt .)
    CONTINUE        reduce using rule 27 (stmt -> continue_stmt .)
    BREAK           reduce using rule 27 (stmt -> continue_stmt .)
    ERET            reduce using rule 27 (stmt -> continue_stmt .)
    !               reduce using rule 27 (stmt -> continue_stmt .)
    -               reduce using rule 27 (stmt -> continue_stmt .)
    +               reduce using rule 27 (stmt -> continue_stmt .)
    ~               reduce using rule 27 (stmt -> continue_stmt .)
    (               reduce using rule 27 (stmt -> continue_stmt .)
    NUMBER          reduce using rule 27 (stmt -> continue_stmt .)
    ELSE            reduce using rule 27 (stmt -> continue_stmt .)


state 47

    (66) expr -> + . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 73

state 48

    (65) expr -> - . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 74

state 49

    (23) stmt -> block_stmt .

    }               reduce using rule 23 (stmt -> block_stmt .)
    VARIABLE        reduce using rule 23 (stmt -> block_stmt .)
    $               reduce using rule 23 (stmt -> block_stmt .)
    {               reduce using rule 23 (stmt -> block_stmt .)
    IF              reduce using rule 23 (stmt -> block_stmt .)
    WHILE           reduce using rule 23 (stmt -> block_stmt .)
    RETURN          reduce using rule 23 (stmt -> block_stmt .)
    CONTINUE        reduce using rule 23 (stmt -> block_stmt .)
    BREAK           reduce using rule 23 (stmt -> block_stmt .)
    ERET            reduce using rule 23 (stmt -> block_stmt .)
    !               reduce using rule 23 (stmt -> block_stmt .)
    -               reduce using rule 23 (stmt -> block_stmt .)
    +               reduce using rule 23 (stmt -> block_stmt .)
    ~               reduce using rule 23 (stmt -> block_stmt .)
    (               reduce using rule 23 (stmt -> block_stmt .)
    NUMBER          reduce using rule 23 (stmt -> block_stmt .)
    ELSE            reduce using rule 23 (stmt -> block_stmt .)


state 50

    (29) stmt -> eret_stmt .

    }               reduce using rule 29 (stmt -> eret_stmt .)
    VARIABLE        reduce using rule 29 (stmt -> eret_stmt .)
    $               reduce using rule 29 (stmt -> eret_stmt .)
    {               reduce using rule 29 (stmt -> eret_stmt .)
    IF              reduce using rule 29 (stmt -> eret_stmt .)
    WHILE           reduce using rule 29 (stmt -> eret_stmt .)
    RETURN          reduce using rule 29 (stmt -> eret_stmt .)
    CONTINUE        reduce using rule 29 (stmt -> eret_stmt .)
    BREAK           reduce using rule 29 (stmt -> eret_stmt .)
    ERET            reduce using rule 29 (stmt -> eret_stmt .)
    !               reduce using rule 29 (stmt -> eret_stmt .)
    -               reduce using rule 29 (stmt -> eret_stmt .)
    +               reduce using rule 29 (stmt -> eret_stmt .)
    ~               reduce using rule 29 (stmt -> eret_stmt .)
    (               reduce using rule 29 (stmt -> eret_stmt .)
    NUMBER          reduce using rule 29 (stmt -> eret_stmt .)
    ELSE            reduce using rule 29 (stmt -> eret_stmt .)


state 51

    (20) stmt_list -> stmt_list stmt .

    }               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    VARIABLE        reduce using rule 20 (stmt_list -> stmt_list stmt .)
    $               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 20 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 20 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 20 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 20 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 20 (stmt_list -> stmt_list stmt .)
    ERET            reduce using rule 20 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    ~               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 20 (stmt_list -> stmt_list stmt .)
    NUMBER          reduce using rule 20 (stmt_list -> stmt_list stmt .)


state 52

    (64) expr -> ! . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 75

state 53

    (31) expr_stmt -> VARIABLE . = expr ;
    (32) expr_stmt -> VARIABLE . [ expr ] = expr ;
    (69) expr -> VARIABLE .
    (72) expr -> VARIABLE . [ expr ]
    (73) expr -> VARIABLE . ( args )

    =               shift and go to state 77
    [               shift and go to state 78
    ;               reduce using rule 69 (expr -> VARIABLE .)
    OR              reduce using rule 69 (expr -> VARIABLE .)
    AND             reduce using rule 69 (expr -> VARIABLE .)
    EQ              reduce using rule 69 (expr -> VARIABLE .)
    NE              reduce using rule 69 (expr -> VARIABLE .)
    LE              reduce using rule 69 (expr -> VARIABLE .)
    LT              reduce using rule 69 (expr -> VARIABLE .)
    GE              reduce using rule 69 (expr -> VARIABLE .)
    GT              reduce using rule 69 (expr -> VARIABLE .)
    *               reduce using rule 69 (expr -> VARIABLE .)
    /               reduce using rule 69 (expr -> VARIABLE .)
    %               reduce using rule 69 (expr -> VARIABLE .)
    +               reduce using rule 69 (expr -> VARIABLE .)
    -               reduce using rule 69 (expr -> VARIABLE .)
    &               reduce using rule 69 (expr -> VARIABLE .)
    ^               reduce using rule 69 (expr -> VARIABLE .)
    |               reduce using rule 69 (expr -> VARIABLE .)
    LSHIFT          reduce using rule 69 (expr -> VARIABLE .)
    RSHIFT          reduce using rule 69 (expr -> VARIABLE .)
    (               shift and go to state 76


state 54

    (22) stmt -> expr_stmt .

    }               reduce using rule 22 (stmt -> expr_stmt .)
    VARIABLE        reduce using rule 22 (stmt -> expr_stmt .)
    $               reduce using rule 22 (stmt -> expr_stmt .)
    {               reduce using rule 22 (stmt -> expr_stmt .)
    IF              reduce using rule 22 (stmt -> expr_stmt .)
    WHILE           reduce using rule 22 (stmt -> expr_stmt .)
    RETURN          reduce using rule 22 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 22 (stmt -> expr_stmt .)
    BREAK           reduce using rule 22 (stmt -> expr_stmt .)
    ERET            reduce using rule 22 (stmt -> expr_stmt .)
    !               reduce using rule 22 (stmt -> expr_stmt .)
    -               reduce using rule 22 (stmt -> expr_stmt .)
    +               reduce using rule 22 (stmt -> expr_stmt .)
    ~               reduce using rule 22 (stmt -> expr_stmt .)
    (               reduce using rule 22 (stmt -> expr_stmt .)
    NUMBER          reduce using rule 22 (stmt -> expr_stmt .)
    ELSE            reduce using rule 22 (stmt -> expr_stmt .)


state 55

    (42) if_stmt -> IF . ( expr ) stmt
    (43) if_stmt -> IF . ( expr ) stmt ELSE stmt

    (               shift and go to state 79


state 56

    (24) stmt -> if_stmt .

    }               reduce using rule 24 (stmt -> if_stmt .)
    VARIABLE        reduce using rule 24 (stmt -> if_stmt .)
    $               reduce using rule 24 (stmt -> if_stmt .)
    {               reduce using rule 24 (stmt -> if_stmt .)
    IF              reduce using rule 24 (stmt -> if_stmt .)
    WHILE           reduce using rule 24 (stmt -> if_stmt .)
    RETURN          reduce using rule 24 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 24 (stmt -> if_stmt .)
    BREAK           reduce using rule 24 (stmt -> if_stmt .)
    ERET            reduce using rule 24 (stmt -> if_stmt .)
    !               reduce using rule 24 (stmt -> if_stmt .)
    -               reduce using rule 24 (stmt -> if_stmt .)
    +               reduce using rule 24 (stmt -> if_stmt .)
    ~               reduce using rule 24 (stmt -> if_stmt .)
    (               reduce using rule 24 (stmt -> if_stmt .)
    NUMBER          reduce using rule 24 (stmt -> if_stmt .)
    ELSE            reduce using rule 24 (stmt -> if_stmt .)


state 57

    (30) eret_stmt -> ERET . ;

    ;               shift and go to state 80


state 58

    (34) expr_stmt -> expr . ;
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ;               shift and go to state 96
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 59

    (79) break_stmt -> BREAK . ;

    ;               shift and go to state 100


state 60

    (25) stmt -> while_stmt .

    }               reduce using rule 25 (stmt -> while_stmt .)
    VARIABLE        reduce using rule 25 (stmt -> while_stmt .)
    $               reduce using rule 25 (stmt -> while_stmt .)
    {               reduce using rule 25 (stmt -> while_stmt .)
    IF              reduce using rule 25 (stmt -> while_stmt .)
    WHILE           reduce using rule 25 (stmt -> while_stmt .)
    RETURN          reduce using rule 25 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 25 (stmt -> while_stmt .)
    BREAK           reduce using rule 25 (stmt -> while_stmt .)
    ERET            reduce using rule 25 (stmt -> while_stmt .)
    !               reduce using rule 25 (stmt -> while_stmt .)
    -               reduce using rule 25 (stmt -> while_stmt .)
    +               reduce using rule 25 (stmt -> while_stmt .)
    ~               reduce using rule 25 (stmt -> while_stmt .)
    (               reduce using rule 25 (stmt -> while_stmt .)
    NUMBER          reduce using rule 25 (stmt -> while_stmt .)
    ELSE            reduce using rule 25 (stmt -> while_stmt .)


state 61

    (78) continue_stmt -> CONTINUE . ;

    ;               shift and go to state 101


state 62

    (68) expr -> ( . expr )
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 102

state 63

    (36) block_stmt -> { . stmt_list }
    (20) stmt_list -> . stmt_list stmt
    (21) stmt_list -> . empty
    (80) empty -> .

    }               reduce using rule 80 (empty -> .)
    VARIABLE        reduce using rule 80 (empty -> .)
    $               reduce using rule 80 (empty -> .)
    {               reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    ERET            reduce using rule 80 (empty -> .)
    !               reduce using rule 80 (empty -> .)
    -               reduce using rule 80 (empty -> .)
    +               reduce using rule 80 (empty -> .)
    ~               reduce using rule 80 (empty -> .)
    (               reduce using rule 80 (empty -> .)
    NUMBER          reduce using rule 80 (empty -> .)

    stmt_list                      shift and go to state 103
    empty                          shift and go to state 39

state 64

    (37) compound_stmt -> { local_decls stmt_list } .

    VOID            reduce using rule 37 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 37 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 37 (compound_stmt -> { local_decls stmt_list } .)


state 65

    (67) expr -> ~ . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 104

state 66

    (40) local_decl -> type_spec VARIABLE . ;
    (41) local_decl -> type_spec VARIABLE . [ NUMBER ] ;

    ;               shift and go to state 105
    [               shift and go to state 106


state 67

    (71) expr -> $ . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 107

state 68

    (44) return_stmt -> RETURN ; .

    }               reduce using rule 44 (return_stmt -> RETURN ; .)
    VARIABLE        reduce using rule 44 (return_stmt -> RETURN ; .)
    $               reduce using rule 44 (return_stmt -> RETURN ; .)
    {               reduce using rule 44 (return_stmt -> RETURN ; .)
    IF              reduce using rule 44 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 44 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 44 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 44 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 44 (return_stmt -> RETURN ; .)
    ERET            reduce using rule 44 (return_stmt -> RETURN ; .)
    !               reduce using rule 44 (return_stmt -> RETURN ; .)
    -               reduce using rule 44 (return_stmt -> RETURN ; .)
    +               reduce using rule 44 (return_stmt -> RETURN ; .)
    ~               reduce using rule 44 (return_stmt -> RETURN ; .)
    (               reduce using rule 44 (return_stmt -> RETURN ; .)
    NUMBER          reduce using rule 44 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 44 (return_stmt -> RETURN ; .)


state 69

    (69) expr -> VARIABLE .
    (72) expr -> VARIABLE . [ expr ]
    (73) expr -> VARIABLE . ( args )

    OR              reduce using rule 69 (expr -> VARIABLE .)
    AND             reduce using rule 69 (expr -> VARIABLE .)
    EQ              reduce using rule 69 (expr -> VARIABLE .)
    NE              reduce using rule 69 (expr -> VARIABLE .)
    LE              reduce using rule 69 (expr -> VARIABLE .)
    LT              reduce using rule 69 (expr -> VARIABLE .)
    GE              reduce using rule 69 (expr -> VARIABLE .)
    GT              reduce using rule 69 (expr -> VARIABLE .)
    *               reduce using rule 69 (expr -> VARIABLE .)
    /               reduce using rule 69 (expr -> VARIABLE .)
    %               reduce using rule 69 (expr -> VARIABLE .)
    +               reduce using rule 69 (expr -> VARIABLE .)
    -               reduce using rule 69 (expr -> VARIABLE .)
    &               reduce using rule 69 (expr -> VARIABLE .)
    ^               reduce using rule 69 (expr -> VARIABLE .)
    |               reduce using rule 69 (expr -> VARIABLE .)
    LSHIFT          reduce using rule 69 (expr -> VARIABLE .)
    RSHIFT          reduce using rule 69 (expr -> VARIABLE .)
    ;               reduce using rule 69 (expr -> VARIABLE .)
    =               reduce using rule 69 (expr -> VARIABLE .)
    )               reduce using rule 69 (expr -> VARIABLE .)
    ,               reduce using rule 69 (expr -> VARIABLE .)
    ]               reduce using rule 69 (expr -> VARIABLE .)
    [               shift and go to state 108
    (               shift and go to state 76


state 70

    (45) return_stmt -> RETURN expr . ;
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ;               shift and go to state 109
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 71

    (35) while_stmt -> WHILE ( . expr ) stmt
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 110

state 72

    (33) expr_stmt -> $ expr . = expr ;
    (71) expr -> $ expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    =               shift and go to state 111
    ;               reduce using rule 71 (expr -> $ expr .)
    OR              reduce using rule 71 (expr -> $ expr .)
    AND             reduce using rule 71 (expr -> $ expr .)
    EQ              reduce using rule 71 (expr -> $ expr .)
    NE              reduce using rule 71 (expr -> $ expr .)
    LE              reduce using rule 71 (expr -> $ expr .)
    LT              reduce using rule 71 (expr -> $ expr .)
    GE              reduce using rule 71 (expr -> $ expr .)
    GT              reduce using rule 71 (expr -> $ expr .)
    *               reduce using rule 71 (expr -> $ expr .)
    /               reduce using rule 71 (expr -> $ expr .)
    %               reduce using rule 71 (expr -> $ expr .)
    +               reduce using rule 71 (expr -> $ expr .)
    -               reduce using rule 71 (expr -> $ expr .)
    &               reduce using rule 71 (expr -> $ expr .)
    ^               reduce using rule 71 (expr -> $ expr .)
    |               reduce using rule 71 (expr -> $ expr .)
    LSHIFT          reduce using rule 71 (expr -> $ expr .)
    RSHIFT          reduce using rule 71 (expr -> $ expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 73

    (66) expr -> + expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 66 (expr -> + expr .)
    AND             reduce using rule 66 (expr -> + expr .)
    EQ              reduce using rule 66 (expr -> + expr .)
    NE              reduce using rule 66 (expr -> + expr .)
    LE              reduce using rule 66 (expr -> + expr .)
    LT              reduce using rule 66 (expr -> + expr .)
    GE              reduce using rule 66 (expr -> + expr .)
    GT              reduce using rule 66 (expr -> + expr .)
    *               reduce using rule 66 (expr -> + expr .)
    /               reduce using rule 66 (expr -> + expr .)
    %               reduce using rule 66 (expr -> + expr .)
    +               reduce using rule 66 (expr -> + expr .)
    -               reduce using rule 66 (expr -> + expr .)
    &               reduce using rule 66 (expr -> + expr .)
    ^               reduce using rule 66 (expr -> + expr .)
    |               reduce using rule 66 (expr -> + expr .)
    LSHIFT          reduce using rule 66 (expr -> + expr .)
    RSHIFT          reduce using rule 66 (expr -> + expr .)
    ;               reduce using rule 66 (expr -> + expr .)
    =               reduce using rule 66 (expr -> + expr .)
    )               reduce using rule 66 (expr -> + expr .)
    ,               reduce using rule 66 (expr -> + expr .)
    ]               reduce using rule 66 (expr -> + expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 74

    (65) expr -> - expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 65 (expr -> - expr .)
    AND             reduce using rule 65 (expr -> - expr .)
    EQ              reduce using rule 65 (expr -> - expr .)
    NE              reduce using rule 65 (expr -> - expr .)
    LE              reduce using rule 65 (expr -> - expr .)
    LT              reduce using rule 65 (expr -> - expr .)
    GE              reduce using rule 65 (expr -> - expr .)
    GT              reduce using rule 65 (expr -> - expr .)
    *               reduce using rule 65 (expr -> - expr .)
    /               reduce using rule 65 (expr -> - expr .)
    %               reduce using rule 65 (expr -> - expr .)
    +               reduce using rule 65 (expr -> - expr .)
    -               reduce using rule 65 (expr -> - expr .)
    &               reduce using rule 65 (expr -> - expr .)
    ^               reduce using rule 65 (expr -> - expr .)
    |               reduce using rule 65 (expr -> - expr .)
    LSHIFT          reduce using rule 65 (expr -> - expr .)
    RSHIFT          reduce using rule 65 (expr -> - expr .)
    ;               reduce using rule 65 (expr -> - expr .)
    =               reduce using rule 65 (expr -> - expr .)
    )               reduce using rule 65 (expr -> - expr .)
    ,               reduce using rule 65 (expr -> - expr .)
    ]               reduce using rule 65 (expr -> - expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 75

    (64) expr -> ! expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 64 (expr -> ! expr .)
    AND             reduce using rule 64 (expr -> ! expr .)
    EQ              reduce using rule 64 (expr -> ! expr .)
    NE              reduce using rule 64 (expr -> ! expr .)
    LE              reduce using rule 64 (expr -> ! expr .)
    LT              reduce using rule 64 (expr -> ! expr .)
    GE              reduce using rule 64 (expr -> ! expr .)
    GT              reduce using rule 64 (expr -> ! expr .)
    *               reduce using rule 64 (expr -> ! expr .)
    /               reduce using rule 64 (expr -> ! expr .)
    %               reduce using rule 64 (expr -> ! expr .)
    +               reduce using rule 64 (expr -> ! expr .)
    -               reduce using rule 64 (expr -> ! expr .)
    &               reduce using rule 64 (expr -> ! expr .)
    ^               reduce using rule 64 (expr -> ! expr .)
    |               reduce using rule 64 (expr -> ! expr .)
    LSHIFT          reduce using rule 64 (expr -> ! expr .)
    RSHIFT          reduce using rule 64 (expr -> ! expr .)
    ;               reduce using rule 64 (expr -> ! expr .)
    =               reduce using rule 64 (expr -> ! expr .)
    )               reduce using rule 64 (expr -> ! expr .)
    ,               reduce using rule 64 (expr -> ! expr .)
    ]               reduce using rule 64 (expr -> ! expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 76

    (73) expr -> VARIABLE ( . args )
    (74) args -> . arg_list
    (75) args -> . empty
    (76) arg_list -> . arg_list , expr
    (77) arg_list -> . expr
    (80) empty -> .
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    )               reduce using rule 80 (empty -> .)
    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 115
    args                           shift and go to state 114
    empty                          shift and go to state 112
    arg_list                       shift and go to state 113

state 77

    (31) expr_stmt -> VARIABLE = . expr ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 116

state 78

    (32) expr_stmt -> VARIABLE [ . expr ] = expr ;
    (72) expr -> VARIABLE [ . expr ]
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 117

state 79

    (42) if_stmt -> IF ( . expr ) stmt
    (43) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 118

state 80

    (30) eret_stmt -> ERET ; .

    }               reduce using rule 30 (eret_stmt -> ERET ; .)
    VARIABLE        reduce using rule 30 (eret_stmt -> ERET ; .)
    $               reduce using rule 30 (eret_stmt -> ERET ; .)
    {               reduce using rule 30 (eret_stmt -> ERET ; .)
    IF              reduce using rule 30 (eret_stmt -> ERET ; .)
    WHILE           reduce using rule 30 (eret_stmt -> ERET ; .)
    RETURN          reduce using rule 30 (eret_stmt -> ERET ; .)
    CONTINUE        reduce using rule 30 (eret_stmt -> ERET ; .)
    BREAK           reduce using rule 30 (eret_stmt -> ERET ; .)
    ERET            reduce using rule 30 (eret_stmt -> ERET ; .)
    !               reduce using rule 30 (eret_stmt -> ERET ; .)
    -               reduce using rule 30 (eret_stmt -> ERET ; .)
    +               reduce using rule 30 (eret_stmt -> ERET ; .)
    ~               reduce using rule 30 (eret_stmt -> ERET ; .)
    (               reduce using rule 30 (eret_stmt -> ERET ; .)
    NUMBER          reduce using rule 30 (eret_stmt -> ERET ; .)
    ELSE            reduce using rule 30 (eret_stmt -> ERET ; .)


state 81

    (47) expr -> expr AND . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 119

state 82

    (50) expr -> expr LE . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 120

state 83

    (52) expr -> expr GE . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 121

state 84

    (63) expr -> expr RSHIFT . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 122

state 85

    (59) expr -> expr & . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 123

state 86

    (57) expr -> expr + . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 124

state 87

    (54) expr -> expr * . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 125

state 88

    (58) expr -> expr - . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 126

state 89

    (49) expr -> expr NE . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 127

state 90

    (55) expr -> expr / . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 128

state 91

    (61) expr -> expr | . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 129

state 92

    (51) expr -> expr LT . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 130

state 93

    (53) expr -> expr GT . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 131

state 94

    (62) expr -> expr LSHIFT . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 132

state 95

    (56) expr -> expr % . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 133

state 96

    (34) expr_stmt -> expr ; .

    }               reduce using rule 34 (expr_stmt -> expr ; .)
    VARIABLE        reduce using rule 34 (expr_stmt -> expr ; .)
    $               reduce using rule 34 (expr_stmt -> expr ; .)
    {               reduce using rule 34 (expr_stmt -> expr ; .)
    IF              reduce using rule 34 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 34 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 34 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 34 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 34 (expr_stmt -> expr ; .)
    ERET            reduce using rule 34 (expr_stmt -> expr ; .)
    !               reduce using rule 34 (expr_stmt -> expr ; .)
    -               reduce using rule 34 (expr_stmt -> expr ; .)
    +               reduce using rule 34 (expr_stmt -> expr ; .)
    ~               reduce using rule 34 (expr_stmt -> expr ; .)
    (               reduce using rule 34 (expr_stmt -> expr ; .)
    NUMBER          reduce using rule 34 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 34 (expr_stmt -> expr ; .)


state 97

    (48) expr -> expr EQ . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 134

state 98

    (46) expr -> expr OR . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 135

state 99

    (60) expr -> expr ^ . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 136

state 100

    (79) break_stmt -> BREAK ; .

    }               reduce using rule 79 (break_stmt -> BREAK ; .)
    VARIABLE        reduce using rule 79 (break_stmt -> BREAK ; .)
    $               reduce using rule 79 (break_stmt -> BREAK ; .)
    {               reduce using rule 79 (break_stmt -> BREAK ; .)
    IF              reduce using rule 79 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 79 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 79 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 79 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 79 (break_stmt -> BREAK ; .)
    ERET            reduce using rule 79 (break_stmt -> BREAK ; .)
    !               reduce using rule 79 (break_stmt -> BREAK ; .)
    -               reduce using rule 79 (break_stmt -> BREAK ; .)
    +               reduce using rule 79 (break_stmt -> BREAK ; .)
    ~               reduce using rule 79 (break_stmt -> BREAK ; .)
    (               reduce using rule 79 (break_stmt -> BREAK ; .)
    NUMBER          reduce using rule 79 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 79 (break_stmt -> BREAK ; .)


state 101

    (78) continue_stmt -> CONTINUE ; .

    }               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    VARIABLE        reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    $               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    {               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    IF              reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    ERET            reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    !               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    -               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    +               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    ~               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    (               reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    NUMBER          reduce using rule 78 (continue_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 78 (continue_stmt -> CONTINUE ; .)


state 102

    (68) expr -> ( expr . )
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    )               shift and go to state 137
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 103

    (36) block_stmt -> { stmt_list . }
    (20) stmt_list -> stmt_list . stmt
    (22) stmt -> . expr_stmt
    (23) stmt -> . block_stmt
    (24) stmt -> . if_stmt
    (25) stmt -> . while_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . continue_stmt
    (28) stmt -> . break_stmt
    (29) stmt -> . eret_stmt
    (31) expr_stmt -> . VARIABLE = expr ;
    (32) expr_stmt -> . VARIABLE [ expr ] = expr ;
    (33) expr_stmt -> . $ expr = expr ;
    (34) expr_stmt -> . expr ;
    (36) block_stmt -> . { stmt_list }
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (35) while_stmt -> . WHILE ( expr ) stmt
    (44) return_stmt -> . RETURN ;
    (45) return_stmt -> . RETURN expr ;
    (78) continue_stmt -> . CONTINUE ;
    (79) break_stmt -> . BREAK ;
    (30) eret_stmt -> . ERET ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    }               shift and go to state 138
    VARIABLE        shift and go to state 53
    $               shift and go to state 45
    {               shift and go to state 63
    IF              shift and go to state 55
    WHILE           shift and go to state 42
    RETURN          shift and go to state 40
    CONTINUE        shift and go to state 61
    BREAK           shift and go to state 59
    ERET            shift and go to state 57
    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    NUMBER          shift and go to state 41

    break_stmt                     shift and go to state 44
    if_stmt                        shift and go to state 56
    continue_stmt                  shift and go to state 46
    block_stmt                     shift and go to state 49
    while_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 43
    stmt                           shift and go to state 51
    eret_stmt                      shift and go to state 50
    expr                           shift and go to state 58
    expr_stmt                      shift and go to state 54

state 104

    (67) expr -> ~ expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 67 (expr -> ~ expr .)
    AND             reduce using rule 67 (expr -> ~ expr .)
    EQ              reduce using rule 67 (expr -> ~ expr .)
    NE              reduce using rule 67 (expr -> ~ expr .)
    LE              reduce using rule 67 (expr -> ~ expr .)
    LT              reduce using rule 67 (expr -> ~ expr .)
    GE              reduce using rule 67 (expr -> ~ expr .)
    GT              reduce using rule 67 (expr -> ~ expr .)
    *               reduce using rule 67 (expr -> ~ expr .)
    /               reduce using rule 67 (expr -> ~ expr .)
    %               reduce using rule 67 (expr -> ~ expr .)
    +               reduce using rule 67 (expr -> ~ expr .)
    -               reduce using rule 67 (expr -> ~ expr .)
    &               reduce using rule 67 (expr -> ~ expr .)
    ^               reduce using rule 67 (expr -> ~ expr .)
    |               reduce using rule 67 (expr -> ~ expr .)
    LSHIFT          reduce using rule 67 (expr -> ~ expr .)
    RSHIFT          reduce using rule 67 (expr -> ~ expr .)
    ;               reduce using rule 67 (expr -> ~ expr .)
    =               reduce using rule 67 (expr -> ~ expr .)
    )               reduce using rule 67 (expr -> ~ expr .)
    ,               reduce using rule 67 (expr -> ~ expr .)
    ]               reduce using rule 67 (expr -> ~ expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 105

    (40) local_decl -> type_spec VARIABLE ; .

    VOID            reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    INT             reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    }               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    VARIABLE        reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    $               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    {               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    IF              reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    WHILE           reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    RETURN          reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    CONTINUE        reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    BREAK           reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    ERET            reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    !               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    -               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    +               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    ~               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    (               reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)
    NUMBER          reduce using rule 40 (local_decl -> type_spec VARIABLE ; .)


state 106

    (41) local_decl -> type_spec VARIABLE [ . NUMBER ] ;

    NUMBER          shift and go to state 139


state 107

    (71) expr -> $ expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 71 (expr -> $ expr .)
    AND             reduce using rule 71 (expr -> $ expr .)
    EQ              reduce using rule 71 (expr -> $ expr .)
    NE              reduce using rule 71 (expr -> $ expr .)
    LE              reduce using rule 71 (expr -> $ expr .)
    LT              reduce using rule 71 (expr -> $ expr .)
    GE              reduce using rule 71 (expr -> $ expr .)
    GT              reduce using rule 71 (expr -> $ expr .)
    *               reduce using rule 71 (expr -> $ expr .)
    /               reduce using rule 71 (expr -> $ expr .)
    %               reduce using rule 71 (expr -> $ expr .)
    +               reduce using rule 71 (expr -> $ expr .)
    -               reduce using rule 71 (expr -> $ expr .)
    &               reduce using rule 71 (expr -> $ expr .)
    ^               reduce using rule 71 (expr -> $ expr .)
    |               reduce using rule 71 (expr -> $ expr .)
    LSHIFT          reduce using rule 71 (expr -> $ expr .)
    RSHIFT          reduce using rule 71 (expr -> $ expr .)
    ;               reduce using rule 71 (expr -> $ expr .)
    =               reduce using rule 71 (expr -> $ expr .)
    )               reduce using rule 71 (expr -> $ expr .)
    ,               reduce using rule 71 (expr -> $ expr .)
    ]               reduce using rule 71 (expr -> $ expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 108

    (72) expr -> VARIABLE [ . expr ]
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 140

state 109

    (45) return_stmt -> RETURN expr ; .

    }               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    VARIABLE        reduce using rule 45 (return_stmt -> RETURN expr ; .)
    $               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 45 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 45 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 45 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 45 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 45 (return_stmt -> RETURN expr ; .)
    ERET            reduce using rule 45 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    ~               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 45 (return_stmt -> RETURN expr ; .)
    NUMBER          reduce using rule 45 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 45 (return_stmt -> RETURN expr ; .)


state 110

    (35) while_stmt -> WHILE ( expr . ) stmt
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    )               shift and go to state 141
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 111

    (33) expr_stmt -> $ expr = . expr ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 142

state 112

    (75) args -> empty .

    )               reduce using rule 75 (args -> empty .)


state 113

    (74) args -> arg_list .
    (76) arg_list -> arg_list . , expr

    )               reduce using rule 74 (args -> arg_list .)
    ,               shift and go to state 143


state 114

    (73) expr -> VARIABLE ( args . )

    )               shift and go to state 144


state 115

    (77) arg_list -> expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ,               reduce using rule 77 (arg_list -> expr .)
    )               reduce using rule 77 (arg_list -> expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 116

    (31) expr_stmt -> VARIABLE = expr . ;
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ;               shift and go to state 145
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 117

    (32) expr_stmt -> VARIABLE [ expr . ] = expr ;
    (72) expr -> VARIABLE [ expr . ]
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ]               shift and go to state 146
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 118

    (42) if_stmt -> IF ( expr . ) stmt
    (43) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    )               shift and go to state 147
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 119

    (47) expr -> expr AND expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 47 (expr -> expr AND expr .)
    AND             reduce using rule 47 (expr -> expr AND expr .)
    EQ              reduce using rule 47 (expr -> expr AND expr .)
    NE              reduce using rule 47 (expr -> expr AND expr .)
    LE              reduce using rule 47 (expr -> expr AND expr .)
    LT              reduce using rule 47 (expr -> expr AND expr .)
    GE              reduce using rule 47 (expr -> expr AND expr .)
    GT              reduce using rule 47 (expr -> expr AND expr .)
    ;               reduce using rule 47 (expr -> expr AND expr .)
    =               reduce using rule 47 (expr -> expr AND expr .)
    )               reduce using rule 47 (expr -> expr AND expr .)
    ,               reduce using rule 47 (expr -> expr AND expr .)
    ]               reduce using rule 47 (expr -> expr AND expr .)
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! *               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! +               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! &               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! ^               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! |               [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! LSHIFT          [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! RSHIFT          [ reduce using rule 47 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 120

    (50) expr -> expr LE expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    EQ              reduce using rule 50 (expr -> expr LE expr .)
    NE              reduce using rule 50 (expr -> expr LE expr .)
    LE              reduce using rule 50 (expr -> expr LE expr .)
    LT              reduce using rule 50 (expr -> expr LE expr .)
    GE              reduce using rule 50 (expr -> expr LE expr .)
    GT              reduce using rule 50 (expr -> expr LE expr .)
    ;               reduce using rule 50 (expr -> expr LE expr .)
    =               reduce using rule 50 (expr -> expr LE expr .)
    )               reduce using rule 50 (expr -> expr LE expr .)
    ,               reduce using rule 50 (expr -> expr LE expr .)
    ]               reduce using rule 50 (expr -> expr LE expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! OR              [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! AND             [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! %               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! +               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! &               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! ^               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! |               [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! LSHIFT          [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! RSHIFT          [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 121

    (52) expr -> expr GE expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    EQ              reduce using rule 52 (expr -> expr GE expr .)
    NE              reduce using rule 52 (expr -> expr GE expr .)
    LE              reduce using rule 52 (expr -> expr GE expr .)
    LT              reduce using rule 52 (expr -> expr GE expr .)
    GE              reduce using rule 52 (expr -> expr GE expr .)
    GT              reduce using rule 52 (expr -> expr GE expr .)
    ;               reduce using rule 52 (expr -> expr GE expr .)
    =               reduce using rule 52 (expr -> expr GE expr .)
    )               reduce using rule 52 (expr -> expr GE expr .)
    ,               reduce using rule 52 (expr -> expr GE expr .)
    ]               reduce using rule 52 (expr -> expr GE expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! OR              [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! AND             [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! *               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! /               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! %               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! +               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! -               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! &               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! ^               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! |               [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! LSHIFT          [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! RSHIFT          [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 122

    (63) expr -> expr RSHIFT expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 63 (expr -> expr RSHIFT expr .)
    AND             reduce using rule 63 (expr -> expr RSHIFT expr .)
    EQ              reduce using rule 63 (expr -> expr RSHIFT expr .)
    NE              reduce using rule 63 (expr -> expr RSHIFT expr .)
    LE              reduce using rule 63 (expr -> expr RSHIFT expr .)
    LT              reduce using rule 63 (expr -> expr RSHIFT expr .)
    GE              reduce using rule 63 (expr -> expr RSHIFT expr .)
    GT              reduce using rule 63 (expr -> expr RSHIFT expr .)
    *               reduce using rule 63 (expr -> expr RSHIFT expr .)
    /               reduce using rule 63 (expr -> expr RSHIFT expr .)
    %               reduce using rule 63 (expr -> expr RSHIFT expr .)
    +               reduce using rule 63 (expr -> expr RSHIFT expr .)
    -               reduce using rule 63 (expr -> expr RSHIFT expr .)
    &               reduce using rule 63 (expr -> expr RSHIFT expr .)
    ^               reduce using rule 63 (expr -> expr RSHIFT expr .)
    |               reduce using rule 63 (expr -> expr RSHIFT expr .)
    LSHIFT          reduce using rule 63 (expr -> expr RSHIFT expr .)
    RSHIFT          reduce using rule 63 (expr -> expr RSHIFT expr .)
    ;               reduce using rule 63 (expr -> expr RSHIFT expr .)
    =               reduce using rule 63 (expr -> expr RSHIFT expr .)
    )               reduce using rule 63 (expr -> expr RSHIFT expr .)
    ,               reduce using rule 63 (expr -> expr RSHIFT expr .)
    ]               reduce using rule 63 (expr -> expr RSHIFT expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 123

    (59) expr -> expr & expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 59 (expr -> expr & expr .)
    AND             reduce using rule 59 (expr -> expr & expr .)
    EQ              reduce using rule 59 (expr -> expr & expr .)
    NE              reduce using rule 59 (expr -> expr & expr .)
    LE              reduce using rule 59 (expr -> expr & expr .)
    LT              reduce using rule 59 (expr -> expr & expr .)
    GE              reduce using rule 59 (expr -> expr & expr .)
    GT              reduce using rule 59 (expr -> expr & expr .)
    +               reduce using rule 59 (expr -> expr & expr .)
    -               reduce using rule 59 (expr -> expr & expr .)
    &               reduce using rule 59 (expr -> expr & expr .)
    ^               reduce using rule 59 (expr -> expr & expr .)
    |               reduce using rule 59 (expr -> expr & expr .)
    ;               reduce using rule 59 (expr -> expr & expr .)
    =               reduce using rule 59 (expr -> expr & expr .)
    )               reduce using rule 59 (expr -> expr & expr .)
    ,               reduce using rule 59 (expr -> expr & expr .)
    ]               reduce using rule 59 (expr -> expr & expr .)
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! *               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! /               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! %               [ reduce using rule 59 (expr -> expr & expr .) ]
  ! LSHIFT          [ reduce using rule 59 (expr -> expr & expr .) ]
  ! RSHIFT          [ reduce using rule 59 (expr -> expr & expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]


state 124

    (57) expr -> expr + expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 57 (expr -> expr + expr .)
    AND             reduce using rule 57 (expr -> expr + expr .)
    EQ              reduce using rule 57 (expr -> expr + expr .)
    NE              reduce using rule 57 (expr -> expr + expr .)
    LE              reduce using rule 57 (expr -> expr + expr .)
    LT              reduce using rule 57 (expr -> expr + expr .)
    GE              reduce using rule 57 (expr -> expr + expr .)
    GT              reduce using rule 57 (expr -> expr + expr .)
    +               reduce using rule 57 (expr -> expr + expr .)
    -               reduce using rule 57 (expr -> expr + expr .)
    ;               reduce using rule 57 (expr -> expr + expr .)
    =               reduce using rule 57 (expr -> expr + expr .)
    )               reduce using rule 57 (expr -> expr + expr .)
    ,               reduce using rule 57 (expr -> expr + expr .)
    ]               reduce using rule 57 (expr -> expr + expr .)
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! *               [ reduce using rule 57 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 57 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 57 (expr -> expr + expr .) ]
  ! &               [ reduce using rule 57 (expr -> expr + expr .) ]
  ! ^               [ reduce using rule 57 (expr -> expr + expr .) ]
  ! |               [ reduce using rule 57 (expr -> expr + expr .) ]
  ! LSHIFT          [ reduce using rule 57 (expr -> expr + expr .) ]
  ! RSHIFT          [ reduce using rule 57 (expr -> expr + expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]


state 125

    (54) expr -> expr * expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 54 (expr -> expr * expr .)
    AND             reduce using rule 54 (expr -> expr * expr .)
    EQ              reduce using rule 54 (expr -> expr * expr .)
    NE              reduce using rule 54 (expr -> expr * expr .)
    LE              reduce using rule 54 (expr -> expr * expr .)
    LT              reduce using rule 54 (expr -> expr * expr .)
    GE              reduce using rule 54 (expr -> expr * expr .)
    GT              reduce using rule 54 (expr -> expr * expr .)
    *               reduce using rule 54 (expr -> expr * expr .)
    /               reduce using rule 54 (expr -> expr * expr .)
    %               reduce using rule 54 (expr -> expr * expr .)
    +               reduce using rule 54 (expr -> expr * expr .)
    -               reduce using rule 54 (expr -> expr * expr .)
    &               reduce using rule 54 (expr -> expr * expr .)
    ^               reduce using rule 54 (expr -> expr * expr .)
    |               reduce using rule 54 (expr -> expr * expr .)
    ;               reduce using rule 54 (expr -> expr * expr .)
    =               reduce using rule 54 (expr -> expr * expr .)
    )               reduce using rule 54 (expr -> expr * expr .)
    ,               reduce using rule 54 (expr -> expr * expr .)
    ]               reduce using rule 54 (expr -> expr * expr .)
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! LSHIFT          [ reduce using rule 54 (expr -> expr * expr .) ]
  ! RSHIFT          [ reduce using rule 54 (expr -> expr * expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]


state 126

    (58) expr -> expr - expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 58 (expr -> expr - expr .)
    AND             reduce using rule 58 (expr -> expr - expr .)
    EQ              reduce using rule 58 (expr -> expr - expr .)
    NE              reduce using rule 58 (expr -> expr - expr .)
    LE              reduce using rule 58 (expr -> expr - expr .)
    LT              reduce using rule 58 (expr -> expr - expr .)
    GE              reduce using rule 58 (expr -> expr - expr .)
    GT              reduce using rule 58 (expr -> expr - expr .)
    +               reduce using rule 58 (expr -> expr - expr .)
    -               reduce using rule 58 (expr -> expr - expr .)
    ;               reduce using rule 58 (expr -> expr - expr .)
    =               reduce using rule 58 (expr -> expr - expr .)
    )               reduce using rule 58 (expr -> expr - expr .)
    ,               reduce using rule 58 (expr -> expr - expr .)
    ]               reduce using rule 58 (expr -> expr - expr .)
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! *               [ reduce using rule 58 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 58 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 58 (expr -> expr - expr .) ]
  ! &               [ reduce using rule 58 (expr -> expr - expr .) ]
  ! ^               [ reduce using rule 58 (expr -> expr - expr .) ]
  ! |               [ reduce using rule 58 (expr -> expr - expr .) ]
  ! LSHIFT          [ reduce using rule 58 (expr -> expr - expr .) ]
  ! RSHIFT          [ reduce using rule 58 (expr -> expr - expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]


state 127

    (49) expr -> expr NE expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    EQ              reduce using rule 49 (expr -> expr NE expr .)
    NE              reduce using rule 49 (expr -> expr NE expr .)
    LE              reduce using rule 49 (expr -> expr NE expr .)
    LT              reduce using rule 49 (expr -> expr NE expr .)
    GE              reduce using rule 49 (expr -> expr NE expr .)
    GT              reduce using rule 49 (expr -> expr NE expr .)
    ;               reduce using rule 49 (expr -> expr NE expr .)
    =               reduce using rule 49 (expr -> expr NE expr .)
    )               reduce using rule 49 (expr -> expr NE expr .)
    ,               reduce using rule 49 (expr -> expr NE expr .)
    ]               reduce using rule 49 (expr -> expr NE expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! OR              [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! AND             [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! *               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! /               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! %               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! +               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! -               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! &               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! ^               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! |               [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! LSHIFT          [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! RSHIFT          [ reduce using rule 49 (expr -> expr NE expr .) ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 128

    (55) expr -> expr / expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 55 (expr -> expr / expr .)
    AND             reduce using rule 55 (expr -> expr / expr .)
    EQ              reduce using rule 55 (expr -> expr / expr .)
    NE              reduce using rule 55 (expr -> expr / expr .)
    LE              reduce using rule 55 (expr -> expr / expr .)
    LT              reduce using rule 55 (expr -> expr / expr .)
    GE              reduce using rule 55 (expr -> expr / expr .)
    GT              reduce using rule 55 (expr -> expr / expr .)
    *               reduce using rule 55 (expr -> expr / expr .)
    /               reduce using rule 55 (expr -> expr / expr .)
    %               reduce using rule 55 (expr -> expr / expr .)
    +               reduce using rule 55 (expr -> expr / expr .)
    -               reduce using rule 55 (expr -> expr / expr .)
    &               reduce using rule 55 (expr -> expr / expr .)
    ^               reduce using rule 55 (expr -> expr / expr .)
    |               reduce using rule 55 (expr -> expr / expr .)
    ;               reduce using rule 55 (expr -> expr / expr .)
    =               reduce using rule 55 (expr -> expr / expr .)
    )               reduce using rule 55 (expr -> expr / expr .)
    ,               reduce using rule 55 (expr -> expr / expr .)
    ]               reduce using rule 55 (expr -> expr / expr .)
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! LSHIFT          [ reduce using rule 55 (expr -> expr / expr .) ]
  ! RSHIFT          [ reduce using rule 55 (expr -> expr / expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]


state 129

    (61) expr -> expr | expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 61 (expr -> expr | expr .)
    AND             reduce using rule 61 (expr -> expr | expr .)
    EQ              reduce using rule 61 (expr -> expr | expr .)
    NE              reduce using rule 61 (expr -> expr | expr .)
    LE              reduce using rule 61 (expr -> expr | expr .)
    LT              reduce using rule 61 (expr -> expr | expr .)
    GE              reduce using rule 61 (expr -> expr | expr .)
    GT              reduce using rule 61 (expr -> expr | expr .)
    +               reduce using rule 61 (expr -> expr | expr .)
    -               reduce using rule 61 (expr -> expr | expr .)
    |               reduce using rule 61 (expr -> expr | expr .)
    ;               reduce using rule 61 (expr -> expr | expr .)
    =               reduce using rule 61 (expr -> expr | expr .)
    )               reduce using rule 61 (expr -> expr | expr .)
    ,               reduce using rule 61 (expr -> expr | expr .)
    ]               reduce using rule 61 (expr -> expr | expr .)
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    &               shift and go to state 85
    ^               shift and go to state 99
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! *               [ reduce using rule 61 (expr -> expr | expr .) ]
  ! /               [ reduce using rule 61 (expr -> expr | expr .) ]
  ! %               [ reduce using rule 61 (expr -> expr | expr .) ]
  ! &               [ reduce using rule 61 (expr -> expr | expr .) ]
  ! ^               [ reduce using rule 61 (expr -> expr | expr .) ]
  ! LSHIFT          [ reduce using rule 61 (expr -> expr | expr .) ]
  ! RSHIFT          [ reduce using rule 61 (expr -> expr | expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! |               [ shift and go to state 91 ]


state 130

    (51) expr -> expr LT expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    EQ              reduce using rule 51 (expr -> expr LT expr .)
    NE              reduce using rule 51 (expr -> expr LT expr .)
    LE              reduce using rule 51 (expr -> expr LT expr .)
    LT              reduce using rule 51 (expr -> expr LT expr .)
    GE              reduce using rule 51 (expr -> expr LT expr .)
    GT              reduce using rule 51 (expr -> expr LT expr .)
    ;               reduce using rule 51 (expr -> expr LT expr .)
    =               reduce using rule 51 (expr -> expr LT expr .)
    )               reduce using rule 51 (expr -> expr LT expr .)
    ,               reduce using rule 51 (expr -> expr LT expr .)
    ]               reduce using rule 51 (expr -> expr LT expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! OR              [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! AND             [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! *               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! /               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! %               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! +               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! -               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! &               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! ^               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! |               [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! LSHIFT          [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! RSHIFT          [ reduce using rule 51 (expr -> expr LT expr .) ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 131

    (53) expr -> expr GT expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    EQ              reduce using rule 53 (expr -> expr GT expr .)
    NE              reduce using rule 53 (expr -> expr GT expr .)
    LE              reduce using rule 53 (expr -> expr GT expr .)
    LT              reduce using rule 53 (expr -> expr GT expr .)
    GE              reduce using rule 53 (expr -> expr GT expr .)
    GT              reduce using rule 53 (expr -> expr GT expr .)
    ;               reduce using rule 53 (expr -> expr GT expr .)
    =               reduce using rule 53 (expr -> expr GT expr .)
    )               reduce using rule 53 (expr -> expr GT expr .)
    ,               reduce using rule 53 (expr -> expr GT expr .)
    ]               reduce using rule 53 (expr -> expr GT expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! OR              [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! AND             [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! *               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! /               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! %               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! +               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! -               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! &               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! ^               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! |               [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! LSHIFT          [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! RSHIFT          [ reduce using rule 53 (expr -> expr GT expr .) ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 132

    (62) expr -> expr LSHIFT expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 62 (expr -> expr LSHIFT expr .)
    AND             reduce using rule 62 (expr -> expr LSHIFT expr .)
    EQ              reduce using rule 62 (expr -> expr LSHIFT expr .)
    NE              reduce using rule 62 (expr -> expr LSHIFT expr .)
    LE              reduce using rule 62 (expr -> expr LSHIFT expr .)
    LT              reduce using rule 62 (expr -> expr LSHIFT expr .)
    GE              reduce using rule 62 (expr -> expr LSHIFT expr .)
    GT              reduce using rule 62 (expr -> expr LSHIFT expr .)
    *               reduce using rule 62 (expr -> expr LSHIFT expr .)
    /               reduce using rule 62 (expr -> expr LSHIFT expr .)
    %               reduce using rule 62 (expr -> expr LSHIFT expr .)
    +               reduce using rule 62 (expr -> expr LSHIFT expr .)
    -               reduce using rule 62 (expr -> expr LSHIFT expr .)
    &               reduce using rule 62 (expr -> expr LSHIFT expr .)
    ^               reduce using rule 62 (expr -> expr LSHIFT expr .)
    |               reduce using rule 62 (expr -> expr LSHIFT expr .)
    LSHIFT          reduce using rule 62 (expr -> expr LSHIFT expr .)
    RSHIFT          reduce using rule 62 (expr -> expr LSHIFT expr .)
    ;               reduce using rule 62 (expr -> expr LSHIFT expr .)
    =               reduce using rule 62 (expr -> expr LSHIFT expr .)
    )               reduce using rule 62 (expr -> expr LSHIFT expr .)
    ,               reduce using rule 62 (expr -> expr LSHIFT expr .)
    ]               reduce using rule 62 (expr -> expr LSHIFT expr .)

  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 94 ]
  ! RSHIFT          [ shift and go to state 84 ]


state 133

    (56) expr -> expr % expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 56 (expr -> expr % expr .)
    AND             reduce using rule 56 (expr -> expr % expr .)
    EQ              reduce using rule 56 (expr -> expr % expr .)
    NE              reduce using rule 56 (expr -> expr % expr .)
    LE              reduce using rule 56 (expr -> expr % expr .)
    LT              reduce using rule 56 (expr -> expr % expr .)
    GE              reduce using rule 56 (expr -> expr % expr .)
    GT              reduce using rule 56 (expr -> expr % expr .)
    *               reduce using rule 56 (expr -> expr % expr .)
    /               reduce using rule 56 (expr -> expr % expr .)
    %               reduce using rule 56 (expr -> expr % expr .)
    +               reduce using rule 56 (expr -> expr % expr .)
    -               reduce using rule 56 (expr -> expr % expr .)
    &               reduce using rule 56 (expr -> expr % expr .)
    ^               reduce using rule 56 (expr -> expr % expr .)
    |               reduce using rule 56 (expr -> expr % expr .)
    ;               reduce using rule 56 (expr -> expr % expr .)
    =               reduce using rule 56 (expr -> expr % expr .)
    )               reduce using rule 56 (expr -> expr % expr .)
    ,               reduce using rule 56 (expr -> expr % expr .)
    ]               reduce using rule 56 (expr -> expr % expr .)
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! LSHIFT          [ reduce using rule 56 (expr -> expr % expr .) ]
  ! RSHIFT          [ reduce using rule 56 (expr -> expr % expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! *               [ shift and go to state 87 ]
  ! /               [ shift and go to state 90 ]
  ! %               [ shift and go to state 95 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]


state 134

    (48) expr -> expr EQ expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    EQ              reduce using rule 48 (expr -> expr EQ expr .)
    NE              reduce using rule 48 (expr -> expr EQ expr .)
    LE              reduce using rule 48 (expr -> expr EQ expr .)
    LT              reduce using rule 48 (expr -> expr EQ expr .)
    GE              reduce using rule 48 (expr -> expr EQ expr .)
    GT              reduce using rule 48 (expr -> expr EQ expr .)
    ;               reduce using rule 48 (expr -> expr EQ expr .)
    =               reduce using rule 48 (expr -> expr EQ expr .)
    )               reduce using rule 48 (expr -> expr EQ expr .)
    ,               reduce using rule 48 (expr -> expr EQ expr .)
    ]               reduce using rule 48 (expr -> expr EQ expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! OR              [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! AND             [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! +               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! &               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! ^               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! |               [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! LSHIFT          [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! RSHIFT          [ reduce using rule 48 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 135

    (46) expr -> expr OR expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 46 (expr -> expr OR expr .)
    AND             reduce using rule 46 (expr -> expr OR expr .)
    EQ              reduce using rule 46 (expr -> expr OR expr .)
    NE              reduce using rule 46 (expr -> expr OR expr .)
    LE              reduce using rule 46 (expr -> expr OR expr .)
    LT              reduce using rule 46 (expr -> expr OR expr .)
    GE              reduce using rule 46 (expr -> expr OR expr .)
    GT              reduce using rule 46 (expr -> expr OR expr .)
    ;               reduce using rule 46 (expr -> expr OR expr .)
    =               reduce using rule 46 (expr -> expr OR expr .)
    )               reduce using rule 46 (expr -> expr OR expr .)
    ,               reduce using rule 46 (expr -> expr OR expr .)
    ]               reduce using rule 46 (expr -> expr OR expr .)
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! *               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! +               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! &               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! ^               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! |               [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! LSHIFT          [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! RSHIFT          [ reduce using rule 46 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]


state 136

    (60) expr -> expr ^ expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    OR              reduce using rule 60 (expr -> expr ^ expr .)
    AND             reduce using rule 60 (expr -> expr ^ expr .)
    EQ              reduce using rule 60 (expr -> expr ^ expr .)
    NE              reduce using rule 60 (expr -> expr ^ expr .)
    LE              reduce using rule 60 (expr -> expr ^ expr .)
    LT              reduce using rule 60 (expr -> expr ^ expr .)
    GE              reduce using rule 60 (expr -> expr ^ expr .)
    GT              reduce using rule 60 (expr -> expr ^ expr .)
    +               reduce using rule 60 (expr -> expr ^ expr .)
    -               reduce using rule 60 (expr -> expr ^ expr .)
    &               reduce using rule 60 (expr -> expr ^ expr .)
    ^               reduce using rule 60 (expr -> expr ^ expr .)
    |               reduce using rule 60 (expr -> expr ^ expr .)
    ;               reduce using rule 60 (expr -> expr ^ expr .)
    =               reduce using rule 60 (expr -> expr ^ expr .)
    )               reduce using rule 60 (expr -> expr ^ expr .)
    ,               reduce using rule 60 (expr -> expr ^ expr .)
    ]               reduce using rule 60 (expr -> expr ^ expr .)
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84

  ! *               [ reduce using rule 60 (expr -> expr ^ expr .) ]
  ! /               [ reduce using rule 60 (expr -> expr ^ expr .) ]
  ! %               [ reduce using rule 60 (expr -> expr ^ expr .) ]
  ! LSHIFT          [ reduce using rule 60 (expr -> expr ^ expr .) ]
  ! RSHIFT          [ reduce using rule 60 (expr -> expr ^ expr .) ]
  ! OR              [ shift and go to state 98 ]
  ! AND             [ shift and go to state 81 ]
  ! EQ              [ shift and go to state 97 ]
  ! NE              [ shift and go to state 89 ]
  ! LE              [ shift and go to state 82 ]
  ! LT              [ shift and go to state 92 ]
  ! GE              [ shift and go to state 83 ]
  ! GT              [ shift and go to state 93 ]
  ! +               [ shift and go to state 86 ]
  ! -               [ shift and go to state 88 ]
  ! &               [ shift and go to state 85 ]
  ! ^               [ shift and go to state 99 ]
  ! |               [ shift and go to state 91 ]


state 137

    (68) expr -> ( expr ) .

    OR              reduce using rule 68 (expr -> ( expr ) .)
    AND             reduce using rule 68 (expr -> ( expr ) .)
    EQ              reduce using rule 68 (expr -> ( expr ) .)
    NE              reduce using rule 68 (expr -> ( expr ) .)
    LE              reduce using rule 68 (expr -> ( expr ) .)
    LT              reduce using rule 68 (expr -> ( expr ) .)
    GE              reduce using rule 68 (expr -> ( expr ) .)
    GT              reduce using rule 68 (expr -> ( expr ) .)
    *               reduce using rule 68 (expr -> ( expr ) .)
    /               reduce using rule 68 (expr -> ( expr ) .)
    %               reduce using rule 68 (expr -> ( expr ) .)
    +               reduce using rule 68 (expr -> ( expr ) .)
    -               reduce using rule 68 (expr -> ( expr ) .)
    &               reduce using rule 68 (expr -> ( expr ) .)
    ^               reduce using rule 68 (expr -> ( expr ) .)
    |               reduce using rule 68 (expr -> ( expr ) .)
    LSHIFT          reduce using rule 68 (expr -> ( expr ) .)
    RSHIFT          reduce using rule 68 (expr -> ( expr ) .)
    ;               reduce using rule 68 (expr -> ( expr ) .)
    =               reduce using rule 68 (expr -> ( expr ) .)
    )               reduce using rule 68 (expr -> ( expr ) .)
    ,               reduce using rule 68 (expr -> ( expr ) .)
    ]               reduce using rule 68 (expr -> ( expr ) .)


state 138

    (36) block_stmt -> { stmt_list } .

    }               reduce using rule 36 (block_stmt -> { stmt_list } .)
    VARIABLE        reduce using rule 36 (block_stmt -> { stmt_list } .)
    $               reduce using rule 36 (block_stmt -> { stmt_list } .)
    {               reduce using rule 36 (block_stmt -> { stmt_list } .)
    IF              reduce using rule 36 (block_stmt -> { stmt_list } .)
    WHILE           reduce using rule 36 (block_stmt -> { stmt_list } .)
    RETURN          reduce using rule 36 (block_stmt -> { stmt_list } .)
    CONTINUE        reduce using rule 36 (block_stmt -> { stmt_list } .)
    BREAK           reduce using rule 36 (block_stmt -> { stmt_list } .)
    ERET            reduce using rule 36 (block_stmt -> { stmt_list } .)
    !               reduce using rule 36 (block_stmt -> { stmt_list } .)
    -               reduce using rule 36 (block_stmt -> { stmt_list } .)
    +               reduce using rule 36 (block_stmt -> { stmt_list } .)
    ~               reduce using rule 36 (block_stmt -> { stmt_list } .)
    (               reduce using rule 36 (block_stmt -> { stmt_list } .)
    NUMBER          reduce using rule 36 (block_stmt -> { stmt_list } .)
    ELSE            reduce using rule 36 (block_stmt -> { stmt_list } .)


state 139

    (41) local_decl -> type_spec VARIABLE [ NUMBER . ] ;

    ]               shift and go to state 148


state 140

    (72) expr -> VARIABLE [ expr . ]
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ]               shift and go to state 149
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 141

    (35) while_stmt -> WHILE ( expr ) . stmt
    (22) stmt -> . expr_stmt
    (23) stmt -> . block_stmt
    (24) stmt -> . if_stmt
    (25) stmt -> . while_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . continue_stmt
    (28) stmt -> . break_stmt
    (29) stmt -> . eret_stmt
    (31) expr_stmt -> . VARIABLE = expr ;
    (32) expr_stmt -> . VARIABLE [ expr ] = expr ;
    (33) expr_stmt -> . $ expr = expr ;
    (34) expr_stmt -> . expr ;
    (36) block_stmt -> . { stmt_list }
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (35) while_stmt -> . WHILE ( expr ) stmt
    (44) return_stmt -> . RETURN ;
    (45) return_stmt -> . RETURN expr ;
    (78) continue_stmt -> . CONTINUE ;
    (79) break_stmt -> . BREAK ;
    (30) eret_stmt -> . ERET ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    VARIABLE        shift and go to state 53
    $               shift and go to state 45
    {               shift and go to state 63
    IF              shift and go to state 55
    WHILE           shift and go to state 42
    RETURN          shift and go to state 40
    CONTINUE        shift and go to state 61
    BREAK           shift and go to state 59
    ERET            shift and go to state 57
    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    NUMBER          shift and go to state 41

    break_stmt                     shift and go to state 44
    if_stmt                        shift and go to state 56
    expr                           shift and go to state 58
    block_stmt                     shift and go to state 49
    while_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 43
    stmt                           shift and go to state 150
    eret_stmt                      shift and go to state 50
    continue_stmt                  shift and go to state 46
    expr_stmt                      shift and go to state 54

state 142

    (33) expr_stmt -> $ expr = expr . ;
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ;               shift and go to state 151
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 143

    (76) arg_list -> arg_list , . expr
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 152

state 144

    (73) expr -> VARIABLE ( args ) .

    OR              reduce using rule 73 (expr -> VARIABLE ( args ) .)
    AND             reduce using rule 73 (expr -> VARIABLE ( args ) .)
    EQ              reduce using rule 73 (expr -> VARIABLE ( args ) .)
    NE              reduce using rule 73 (expr -> VARIABLE ( args ) .)
    LE              reduce using rule 73 (expr -> VARIABLE ( args ) .)
    LT              reduce using rule 73 (expr -> VARIABLE ( args ) .)
    GE              reduce using rule 73 (expr -> VARIABLE ( args ) .)
    GT              reduce using rule 73 (expr -> VARIABLE ( args ) .)
    *               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    /               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    %               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    +               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    -               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    &               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    ^               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    |               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    LSHIFT          reduce using rule 73 (expr -> VARIABLE ( args ) .)
    RSHIFT          reduce using rule 73 (expr -> VARIABLE ( args ) .)
    ;               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    =               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    )               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    ,               reduce using rule 73 (expr -> VARIABLE ( args ) .)
    ]               reduce using rule 73 (expr -> VARIABLE ( args ) .)


state 145

    (31) expr_stmt -> VARIABLE = expr ; .

    }               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    VARIABLE        reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    $               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    {               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    IF              reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    WHILE           reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    RETURN          reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    CONTINUE        reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    BREAK           reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    ERET            reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    !               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    -               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    +               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    ~               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    (               reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    NUMBER          reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)
    ELSE            reduce using rule 31 (expr_stmt -> VARIABLE = expr ; .)


state 146

    (32) expr_stmt -> VARIABLE [ expr ] . = expr ;
    (72) expr -> VARIABLE [ expr ] .

    =               shift and go to state 153
    ;               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    OR              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    AND             reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    EQ              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    NE              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    LE              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    LT              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    GE              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    GT              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    *               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    /               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    %               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    +               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    -               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    &               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    ^               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    |               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    LSHIFT          reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    RSHIFT          reduce using rule 72 (expr -> VARIABLE [ expr ] .)


state 147

    (42) if_stmt -> IF ( expr ) . stmt
    (43) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (22) stmt -> . expr_stmt
    (23) stmt -> . block_stmt
    (24) stmt -> . if_stmt
    (25) stmt -> . while_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . continue_stmt
    (28) stmt -> . break_stmt
    (29) stmt -> . eret_stmt
    (31) expr_stmt -> . VARIABLE = expr ;
    (32) expr_stmt -> . VARIABLE [ expr ] = expr ;
    (33) expr_stmt -> . $ expr = expr ;
    (34) expr_stmt -> . expr ;
    (36) block_stmt -> . { stmt_list }
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (35) while_stmt -> . WHILE ( expr ) stmt
    (44) return_stmt -> . RETURN ;
    (45) return_stmt -> . RETURN expr ;
    (78) continue_stmt -> . CONTINUE ;
    (79) break_stmt -> . BREAK ;
    (30) eret_stmt -> . ERET ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    VARIABLE        shift and go to state 53
    $               shift and go to state 45
    {               shift and go to state 63
    IF              shift and go to state 55
    WHILE           shift and go to state 42
    RETURN          shift and go to state 40
    CONTINUE        shift and go to state 61
    BREAK           shift and go to state 59
    ERET            shift and go to state 57
    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    NUMBER          shift and go to state 41

    break_stmt                     shift and go to state 44
    if_stmt                        shift and go to state 56
    expr                           shift and go to state 58
    block_stmt                     shift and go to state 49
    while_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 43
    stmt                           shift and go to state 154
    eret_stmt                      shift and go to state 50
    continue_stmt                  shift and go to state 46
    expr_stmt                      shift and go to state 54

state 148

    (41) local_decl -> type_spec VARIABLE [ NUMBER ] . ;

    ;               shift and go to state 155


state 149

    (72) expr -> VARIABLE [ expr ] .

    OR              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    AND             reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    EQ              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    NE              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    LE              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    LT              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    GE              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    GT              reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    *               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    /               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    %               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    +               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    -               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    &               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    ^               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    |               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    LSHIFT          reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    RSHIFT          reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    ;               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    =               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    )               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    ,               reduce using rule 72 (expr -> VARIABLE [ expr ] .)
    ]               reduce using rule 72 (expr -> VARIABLE [ expr ] .)


state 150

    (35) while_stmt -> WHILE ( expr ) stmt .

    }               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    VARIABLE        reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    $               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    ERET            reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    ~               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    NUMBER          reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 35 (while_stmt -> WHILE ( expr ) stmt .)


state 151

    (33) expr_stmt -> $ expr = expr ; .

    }               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    VARIABLE        reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    $               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    {               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    IF              reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    WHILE           reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    RETURN          reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    CONTINUE        reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    BREAK           reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    ERET            reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    !               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    -               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    +               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    ~               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    (               reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    NUMBER          reduce using rule 33 (expr_stmt -> $ expr = expr ; .)
    ELSE            reduce using rule 33 (expr_stmt -> $ expr = expr ; .)


state 152

    (76) arg_list -> arg_list , expr .
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ,               reduce using rule 76 (arg_list -> arg_list , expr .)
    )               reduce using rule 76 (arg_list -> arg_list , expr .)
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 153

    (32) expr_stmt -> VARIABLE [ expr ] = . expr ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    VARIABLE        shift and go to state 69
    NUMBER          shift and go to state 41
    $               shift and go to state 67

    expr                           shift and go to state 156

state 154

    (42) if_stmt -> IF ( expr ) stmt .
    (43) if_stmt -> IF ( expr ) stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    }               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    VARIABLE        reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    $               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    ERET            reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    ~               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    NUMBER          reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 157

  ! ELSE            [ reduce using rule 42 (if_stmt -> IF ( expr ) stmt .) ]


state 155

    (41) local_decl -> type_spec VARIABLE [ NUMBER ] ; .

    VOID            reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    INT             reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    }               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    VARIABLE        reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    $               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    {               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    IF              reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    WHILE           reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    RETURN          reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    CONTINUE        reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    BREAK           reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    ERET            reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    !               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    -               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    +               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    ~               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    (               reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)
    NUMBER          reduce using rule 41 (local_decl -> type_spec VARIABLE [ NUMBER ] ; .)


state 156

    (32) expr_stmt -> VARIABLE [ expr ] = expr . ;
    (46) expr -> expr . OR expr
    (47) expr -> expr . AND expr
    (48) expr -> expr . EQ expr
    (49) expr -> expr . NE expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . LT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . GT expr
    (54) expr -> expr . * expr
    (55) expr -> expr . / expr
    (56) expr -> expr . % expr
    (57) expr -> expr . + expr
    (58) expr -> expr . - expr
    (59) expr -> expr . & expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . | expr
    (62) expr -> expr . LSHIFT expr
    (63) expr -> expr . RSHIFT expr

    ;               shift and go to state 158
    OR              shift and go to state 98
    AND             shift and go to state 81
    EQ              shift and go to state 97
    NE              shift and go to state 89
    LE              shift and go to state 82
    LT              shift and go to state 92
    GE              shift and go to state 83
    GT              shift and go to state 93
    *               shift and go to state 87
    /               shift and go to state 90
    %               shift and go to state 95
    +               shift and go to state 86
    -               shift and go to state 88
    &               shift and go to state 85
    ^               shift and go to state 99
    |               shift and go to state 91
    LSHIFT          shift and go to state 94
    RSHIFT          shift and go to state 84


state 157

    (43) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (22) stmt -> . expr_stmt
    (23) stmt -> . block_stmt
    (24) stmt -> . if_stmt
    (25) stmt -> . while_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . continue_stmt
    (28) stmt -> . break_stmt
    (29) stmt -> . eret_stmt
    (31) expr_stmt -> . VARIABLE = expr ;
    (32) expr_stmt -> . VARIABLE [ expr ] = expr ;
    (33) expr_stmt -> . $ expr = expr ;
    (34) expr_stmt -> . expr ;
    (36) block_stmt -> . { stmt_list }
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (35) while_stmt -> . WHILE ( expr ) stmt
    (44) return_stmt -> . RETURN ;
    (45) return_stmt -> . RETURN expr ;
    (78) continue_stmt -> . CONTINUE ;
    (79) break_stmt -> . BREAK ;
    (30) eret_stmt -> . ERET ;
    (46) expr -> . expr OR expr
    (47) expr -> . expr AND expr
    (48) expr -> . expr EQ expr
    (49) expr -> . expr NE expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr LT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr GT expr
    (54) expr -> . expr * expr
    (55) expr -> . expr / expr
    (56) expr -> . expr % expr
    (57) expr -> . expr + expr
    (58) expr -> . expr - expr
    (59) expr -> . expr & expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr LSHIFT expr
    (63) expr -> . expr RSHIFT expr
    (64) expr -> . ! expr
    (65) expr -> . - expr
    (66) expr -> . + expr
    (67) expr -> . ~ expr
    (68) expr -> . ( expr )
    (69) expr -> . VARIABLE
    (70) expr -> . NUMBER
    (71) expr -> . $ expr
    (72) expr -> . VARIABLE [ expr ]
    (73) expr -> . VARIABLE ( args )

    VARIABLE        shift and go to state 53
    $               shift and go to state 45
    {               shift and go to state 63
    IF              shift and go to state 55
    WHILE           shift and go to state 42
    RETURN          shift and go to state 40
    CONTINUE        shift and go to state 61
    BREAK           shift and go to state 59
    ERET            shift and go to state 57
    !               shift and go to state 52
    -               shift and go to state 48
    +               shift and go to state 47
    ~               shift and go to state 65
    (               shift and go to state 62
    NUMBER          shift and go to state 41

    break_stmt                     shift and go to state 44
    if_stmt                        shift and go to state 56
    expr                           shift and go to state 58
    block_stmt                     shift and go to state 49
    while_stmt                     shift and go to state 60
    return_stmt                    shift and go to state 43
    stmt                           shift and go to state 159
    eret_stmt                      shift and go to state 50
    continue_stmt                  shift and go to state 46
    expr_stmt                      shift and go to state 54

state 158

    (32) expr_stmt -> VARIABLE [ expr ] = expr ; .

    }               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    VARIABLE        reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    $               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    {               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    IF              reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    WHILE           reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    RETURN          reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    CONTINUE        reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    BREAK           reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    ERET            reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    !               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    -               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    +               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    ~               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    (               reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    NUMBER          reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)
    ELSE            reduce using rule 32 (expr_stmt -> VARIABLE [ expr ] = expr ; .)


state 159

    (43) if_stmt -> IF ( expr ) stmt ELSE stmt .

    }               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    VARIABLE        reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    $               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ERET            reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ~               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NUMBER          reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 154 resolved as shift
